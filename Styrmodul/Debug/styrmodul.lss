
styrmodul.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00000620  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000005ac  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000007  00800100  00800100  00000620  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000620  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000650  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000000d8  00000000  00000000  00000690  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000012e0  00000000  00000000  00000768  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000abf  00000000  00000000  00001a48  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000007e1  00000000  00000000  00002507  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001dc  00000000  00000000  00002ce8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000005bc  00000000  00000000  00002ec4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bf3  00000000  00000000  00003480  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000a8  00000000  00000000  00004073  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
   2:	00 00       	nop
   4:	53 c0       	rjmp	.+166    	; 0xac <__bad_interrupt>
   6:	00 00       	nop
   8:	51 c0       	rjmp	.+162    	; 0xac <__bad_interrupt>
   a:	00 00       	nop
   c:	4f c0       	rjmp	.+158    	; 0xac <__bad_interrupt>
   e:	00 00       	nop
  10:	4d c0       	rjmp	.+154    	; 0xac <__bad_interrupt>
  12:	00 00       	nop
  14:	4b c0       	rjmp	.+150    	; 0xac <__bad_interrupt>
  16:	00 00       	nop
  18:	49 c0       	rjmp	.+146    	; 0xac <__bad_interrupt>
  1a:	00 00       	nop
  1c:	47 c0       	rjmp	.+142    	; 0xac <__bad_interrupt>
  1e:	00 00       	nop
  20:	45 c0       	rjmp	.+138    	; 0xac <__bad_interrupt>
  22:	00 00       	nop
  24:	43 c0       	rjmp	.+134    	; 0xac <__bad_interrupt>
  26:	00 00       	nop
  28:	41 c0       	rjmp	.+130    	; 0xac <__bad_interrupt>
  2a:	00 00       	nop
  2c:	3f c0       	rjmp	.+126    	; 0xac <__bad_interrupt>
  2e:	00 00       	nop
  30:	3d c0       	rjmp	.+122    	; 0xac <__bad_interrupt>
  32:	00 00       	nop
  34:	3b c0       	rjmp	.+118    	; 0xac <__bad_interrupt>
  36:	00 00       	nop
  38:	39 c0       	rjmp	.+114    	; 0xac <__bad_interrupt>
  3a:	00 00       	nop
  3c:	37 c0       	rjmp	.+110    	; 0xac <__bad_interrupt>
  3e:	00 00       	nop
  40:	35 c0       	rjmp	.+106    	; 0xac <__bad_interrupt>
  42:	00 00       	nop
  44:	33 c0       	rjmp	.+102    	; 0xac <__bad_interrupt>
  46:	00 00       	nop
  48:	31 c0       	rjmp	.+98     	; 0xac <__bad_interrupt>
  4a:	00 00       	nop
  4c:	2f c0       	rjmp	.+94     	; 0xac <__bad_interrupt>
  4e:	00 00       	nop
  50:	2d c0       	rjmp	.+90     	; 0xac <__bad_interrupt>
  52:	00 00       	nop
  54:	2b c0       	rjmp	.+86     	; 0xac <__bad_interrupt>
  56:	00 00       	nop
  58:	29 c0       	rjmp	.+82     	; 0xac <__bad_interrupt>
  5a:	00 00       	nop
  5c:	27 c0       	rjmp	.+78     	; 0xac <__bad_interrupt>
  5e:	00 00       	nop
  60:	25 c0       	rjmp	.+74     	; 0xac <__bad_interrupt>
  62:	00 00       	nop
  64:	23 c0       	rjmp	.+70     	; 0xac <__bad_interrupt>
  66:	00 00       	nop
  68:	21 c0       	rjmp	.+66     	; 0xac <__bad_interrupt>
  6a:	00 00       	nop
  6c:	1f c0       	rjmp	.+62     	; 0xac <__bad_interrupt>
  6e:	00 00       	nop
  70:	1d c0       	rjmp	.+58     	; 0xac <__bad_interrupt>
  72:	00 00       	nop
  74:	1b c0       	rjmp	.+54     	; 0xac <__bad_interrupt>
  76:	00 00       	nop
  78:	19 c0       	rjmp	.+50     	; 0xac <__bad_interrupt>
  7a:	00 00       	nop
  7c:	17 c0       	rjmp	.+46     	; 0xac <__bad_interrupt>
  7e:	00 00       	nop
  80:	15 c0       	rjmp	.+42     	; 0xac <__bad_interrupt>
  82:	00 00       	nop
  84:	13 c0       	rjmp	.+38     	; 0xac <__bad_interrupt>
  86:	00 00       	nop
  88:	11 c0       	rjmp	.+34     	; 0xac <__bad_interrupt>
	...

0000008c <__ctors_end>:
  8c:	11 24       	eor	r1, r1
  8e:	1f be       	out	0x3f, r1	; 63
  90:	cf ef       	ldi	r28, 0xFF	; 255
  92:	d0 e4       	ldi	r29, 0x40	; 64
  94:	de bf       	out	0x3e, r29	; 62
  96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_clear_bss>:
  98:	21 e0       	ldi	r18, 0x01	; 1
  9a:	a0 e0       	ldi	r26, 0x00	; 0
  9c:	b1 e0       	ldi	r27, 0x01	; 1
  9e:	01 c0       	rjmp	.+2      	; 0xa2 <.do_clear_bss_start>

000000a0 <.do_clear_bss_loop>:
  a0:	1d 92       	st	X+, r1

000000a2 <.do_clear_bss_start>:
  a2:	a7 30       	cpi	r26, 0x07	; 7
  a4:	b2 07       	cpc	r27, r18
  a6:	e1 f7       	brne	.-8      	; 0xa0 <.do_clear_bss_loop>
  a8:	d3 d1       	rcall	.+934    	; 0x450 <main>
  aa:	7e c2       	rjmp	.+1276   	; 0x5a8 <_exit>

000000ac <__bad_interrupt>:
  ac:	a9 cf       	rjmp	.-174    	; 0x0 <__vectors>

000000ae <Pwm_Gen>:
{
	int tempE;
	tempE = tot_e*K;
	tempE = (tempE>>6);
	return tempE;
}
  ae:	0f 93       	push	r16
  b0:	1f 93       	push	r17
  b2:	cf 93       	push	r28
  b4:	df 93       	push	r29
  b6:	d8 2f       	mov	r29, r24
  b8:	16 2f       	mov	r17, r22
  ba:	c4 2f       	mov	r28, r20
  bc:	02 2f       	mov	r16, r18
  be:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <programState>
  c2:	50 d2       	rcall	.+1184   	; 0x564 <UART_Transmit_sens>
  c4:	00 0f       	add	r16, r16
  c6:	c0 0f       	add	r28, r16
  c8:	c2 95       	swap	r28
  ca:	c0 7f       	andi	r28, 0xF0	; 240
  cc:	c5 b9       	out	0x05, r28	; 5
  ce:	61 2f       	mov	r22, r17
  d0:	70 e0       	ldi	r23, 0x00	; 0
  d2:	70 93 99 00 	sts	0x0099, r23	; 0x800099 <__TEXT_REGION_LENGTH__+0x7e0099>
  d6:	60 93 98 00 	sts	0x0098, r22	; 0x800098 <__TEXT_REGION_LENGTH__+0x7e0098>
  da:	8d 2f       	mov	r24, r29
  dc:	90 e0       	ldi	r25, 0x00	; 0
  de:	90 93 9b 00 	sts	0x009B, r25	; 0x80009b <__TEXT_REGION_LENGTH__+0x7e009b>
  e2:	80 93 9a 00 	sts	0x009A, r24	; 0x80009a <__TEXT_REGION_LENGTH__+0x7e009a>
  e6:	df 91       	pop	r29
  e8:	cf 91       	pop	r28
  ea:	1f 91       	pop	r17
  ec:	0f 91       	pop	r16
  ee:	08 95       	ret

000000f0 <Get_Sensor>:
		Get_Sensor(sen);  //Hämta sensorvärden
	}
	Pwm_Gen(0,0,0,0);
}
void Get_Sensor(unsigned char* sens) // ta emot sensorvärden (för reglering)
{
  f0:	cf 93       	push	r28
  f2:	df 93       	push	r29
  f4:	ec 01       	movw	r28, r24
	unsigned char sanity;
	sanity = UART_Recieve_sens();
  f6:	26 d2       	rcall	.+1100   	; 0x544 <UART_Recieve_sens>
	
	if (sanity == 0b00000000)
  f8:	81 11       	cpse	r24, r1
	{
		for(int i = 0;2>i;i = i+1)
		{
			sens[i] = UART_Recieve_sens();
  fa:	05 c0       	rjmp	.+10     	; 0x106 <Get_Sensor+0x16>
  fc:	23 d2       	rcall	.+1094   	; 0x544 <UART_Recieve_sens>
  fe:	88 83       	st	Y, r24
 100:	21 d2       	rcall	.+1090   	; 0x544 <UART_Recieve_sens>
 102:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	else 
		Get_Sensor(sens);//Återkallas tills den är i sync
 104:	02 c0       	rjmp	.+4      	; 0x10a <Get_Sensor+0x1a>
 106:	ce 01       	movw	r24, r28
 108:	f3 df       	rcall	.-26     	; 0xf0 <Get_Sensor>
}
 10a:	df 91       	pop	r29
 10c:	cf 91       	pop	r28
 10e:	08 95       	ret

00000110 <Regler_Func>:
	tempE = tot_e*K;
	tempE = (tempE>>6);
	return tempE;
}
void Regler_Func(int dir)//Program för att reglera mot en vägg
{  
 110:	2f 92       	push	r2
 112:	3f 92       	push	r3
 114:	4f 92       	push	r4
 116:	5f 92       	push	r5
 118:	6f 92       	push	r6
 11a:	7f 92       	push	r7
 11c:	8f 92       	push	r8
 11e:	9f 92       	push	r9
 120:	af 92       	push	r10
 122:	bf 92       	push	r11
 124:	cf 92       	push	r12
 126:	df 92       	push	r13
 128:	ef 92       	push	r14
 12a:	ff 92       	push	r15
 12c:	0f 93       	push	r16
 12e:	1f 93       	push	r17
 130:	cf 93       	push	r28
 132:	df 93       	push	r29
 134:	00 d0       	rcall	.+0      	; 0x136 <Regler_Func+0x26>
 136:	cd b7       	in	r28, 0x3d	; 61
 138:	de b7       	in	r29, 0x3e	; 62
	programState = 'S';
 13a:	83 e5       	ldi	r24, 0x53	; 83
 13c:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
	int EV_old=0;
	int EH_old=0;
	unsigned char sen[2];  
	int Ev, Eh, StyrSignalHoger, StyrSignalVanster = 0;
	int EFram, EBak,E3,sensorFram,sensorBak;
	USART1_Flush();
 140:	19 d2       	rcall	.+1074   	; 0x574 <USART1_Flush>
	USART0_Flush();
 142:	25 d2       	rcall	.+1098   	; 0x58e <USART0_Flush>
 144:	ce 01       	movw	r24, r28
	Get_Sensor(sen);  //Hämta sensorvärden
 146:	01 96       	adiw	r24, 0x01	; 1
 148:	d3 df       	rcall	.-90     	; 0xf0 <Get_Sensor>
 14a:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
	while( !(UCSR0A & (1<<RXC0))) //sålänge den inte mottar en ny instruktion från com
 14e:	88 23       	and	r24, r24
 150:	0c f4       	brge	.+2      	; 0x154 <Regler_Func+0x44>
 152:	c8 c0       	rjmp	.+400    	; 0x2e4 <Regler_Func+0x1d4>
 154:	81 2c       	mov	r8, r1
 156:	91 2c       	mov	r9, r1
 158:	61 2c       	mov	r6, r1
 15a:	71 2c       	mov	r7, r1
 15c:	aa 24       	eor	r10, r10
		{
			
			sensorFram = 255 - sen[0];		    //F?r n?ra -> l?gt v?rde och vice versa
			sensorBak = 255 - sen[1];
			
			EFram = (sensorFram - W_distance); //Reglerfel: Avstånd
 15e:	aa 94       	dec	r10
 160:	b1 2c       	mov	r11, r1
 162:	41 2c       	mov	r4, r1
			EH_old = Eh;
			
			//else{
			if (StyrSignalVanster + base_pwm > 170) //Begränsingar för att undvika OverFlow och att roboten rusar iväg
			{
				Pwm_left = 170;
 164:	0f 2e       	mov	r0, r31
			}
			else if (StyrSignalVanster + base_pwm < 20)
			{
				Pwm_left = 20;
 166:	f4 e1       	ldi	r31, 0x14	; 20
 168:	3f 2e       	mov	r3, r31
 16a:	f0 2d       	mov	r31, r0
 16c:	51 2c       	mov	r5, r1
 16e:	0f 2e       	mov	r0, r31
				Pwm_left = (StyrSignalVanster + base_pwm);
			}
			/////////////////////////////////////
			if ( StyrSignalHoger + base_pwm > 170)
			{
				Pwm_right =170;
 170:	fa ea       	ldi	r31, 0xAA	; 170
 172:	2f 2e       	mov	r2, r31
 174:	f0 2d       	mov	r31, r0
 176:	0f 2e       	mov	r0, r31
	int Ev, Eh, StyrSignalHoger, StyrSignalVanster = 0;
	int EFram, EBak,E3,sensorFram,sensorBak;
	USART1_Flush();
	USART0_Flush();
	Get_Sensor(sen);  //Hämta sensorvärden
	while( !(UCSR0A & (1<<RXC0))) //sålänge den inte mottar en ny instruktion från com
 178:	f0 ec       	ldi	r31, 0xC0	; 192
 17a:	ef 2e       	mov	r14, r31
 17c:	f1 2c       	mov	r15, r1
 17e:	f0 2d       	mov	r31, r0
 180:	89 81       	ldd	r24, Y+1	; 0x01
	{
		
		if ((sen[0] < 75) || (sen[1] < 75) )
 182:	8b 34       	cpi	r24, 0x4B	; 75
 184:	18 f0       	brcs	.+6      	; 0x18c <Regler_Func+0x7c>
 186:	9a 81       	ldd	r25, Y+2	; 0x02
 188:	9b 34       	cpi	r25, 0x4B	; 75
 18a:	30 f4       	brcc	.+12     	; 0x198 <Regler_Func+0x88>
 18c:	21 e0       	ldi	r18, 0x01	; 1
		{  //Ifall roboten inte ser en vägg på högersida, kör rakt fram
			Pwm_Gen(base_pwm,base_pwm,1,1);
 18e:	41 e0       	ldi	r20, 0x01	; 1
 190:	65 e5       	ldi	r22, 0x55	; 85
 192:	85 e5       	ldi	r24, 0x55	; 85
 194:	8c df       	rcall	.-232    	; 0xae <Pwm_Gen>
 196:	9e c0       	rjmp	.+316    	; 0x2d4 <Regler_Func+0x1c4>
 198:	85 01       	movw	r16, r10
		{
			
			sensorFram = 255 - sen[0];		    //F?r n?ra -> l?gt v?rde och vice versa
			sensorBak = 255 - sen[1];
			
			EFram = (sensorFram - W_distance); //Reglerfel: Avstånd
 19a:	08 1b       	sub	r16, r24
 19c:	11 09       	sbc	r17, r1
 19e:	95 01       	movw	r18, r10
			EBak = (sensorBak - W_distance);
			E3 = EFram - EBak;				   //Reglerfel: SensorSkillnad 
 1a0:	29 1b       	sub	r18, r25
 1a2:	31 09       	sbc	r19, r1
 1a4:	c8 01       	movw	r24, r16
 1a6:	88 57       	subi	r24, 0x78	; 120
 1a8:	91 09       	sbc	r25, r1
 1aa:	02 1b       	sub	r16, r18
 1ac:	13 0b       	sbc	r17, r19
 1ae:	95 95       	asr	r25
			Ev =  E3 + (EFram>>2);                 //Totala felet
 1b0:	87 95       	ror	r24
 1b2:	95 95       	asr	r25
 1b4:	87 95       	ror	r24
 1b6:	68 01       	movw	r12, r16
 1b8:	c8 0e       	add	r12, r24
 1ba:	d9 1e       	adc	r13, r25
 1bc:	11 95       	neg	r17
			Eh =  - E3 - (EFram>>2);
 1be:	01 95       	neg	r16
 1c0:	11 09       	sbc	r17, r1
 1c2:	08 1b       	sub	r16, r24
 1c4:	19 0b       	sbc	r17, r25
 1c6:	80 91 03 01 	lds	r24, 0x0103	; 0x800103 <K>
	return tempKR;
}
int mult_k(int tot_e) //Justerar K-värdet för PD-regulatorn
{
	int tempE;
	tempE = tot_e*K;
 1ca:	90 91 04 01 	lds	r25, 0x0104	; 0x800104 <K+0x1>
 1ce:	96 01       	movw	r18, r12
 1d0:	22 0f       	add	r18, r18
 1d2:	33 1f       	adc	r19, r19
 1d4:	28 9f       	mul	r18, r24
 1d6:	d0 01       	movw	r26, r0
 1d8:	29 9f       	mul	r18, r25
 1da:	b0 0d       	add	r27, r0
 1dc:	38 9f       	mul	r19, r24
 1de:	b0 0d       	add	r27, r0
 1e0:	11 24       	eor	r1, r1
 1e2:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <_edata>
	OCR3B = Right_Pwm; //Pwm till hger sida via port B8
}
int mult_kd(int tot_e) // Justerar KD-värdet för PD-regulator
{
	int tempKD;
	tempKD = tot_e*KD;
 1e6:	90 91 01 01 	lds	r25, 0x0101	; 0x800101 <_edata+0x1>
 1ea:	96 01       	movw	r18, r12
 1ec:	26 19       	sub	r18, r6
 1ee:	37 09       	sbc	r19, r7
 1f0:	28 9f       	mul	r18, r24
 1f2:	b0 01       	movw	r22, r0
 1f4:	29 9f       	mul	r18, r25
 1f6:	70 0d       	add	r23, r0
 1f8:	38 9f       	mul	r19, r24
 1fa:	70 0d       	add	r23, r0
 1fc:	11 24       	eor	r1, r1
 1fe:	20 91 03 01 	lds	r18, 0x0103	; 0x800103 <K>
	return tempKR;
}
int mult_k(int tot_e) //Justerar K-värdet för PD-regulatorn
{
	int tempE;
	tempE = tot_e*K;
 202:	30 91 04 01 	lds	r19, 0x0104	; 0x800104 <K+0x1>
 206:	a8 01       	movw	r20, r16
 208:	44 0f       	add	r20, r20
 20a:	55 1f       	adc	r21, r21
 20c:	42 9f       	mul	r20, r18
 20e:	c0 01       	movw	r24, r0
 210:	43 9f       	mul	r20, r19
 212:	90 0d       	add	r25, r0
 214:	52 9f       	mul	r21, r18
 216:	90 0d       	add	r25, r0
 218:	11 24       	eor	r1, r1
 21a:	40 91 00 01 	lds	r20, 0x0100	; 0x800100 <_edata>
	OCR3B = Right_Pwm; //Pwm till hger sida via port B8
}
int mult_kd(int tot_e) // Justerar KD-värdet för PD-regulator
{
	int tempKD;
	tempKD = tot_e*KD;
 21e:	50 91 01 01 	lds	r21, 0x0101	; 0x800101 <_edata+0x1>
 222:	f8 01       	movw	r30, r16
 224:	e8 19       	sub	r30, r8
 226:	f9 09       	sbc	r31, r9
 228:	e4 9f       	mul	r30, r20
 22a:	90 01       	movw	r18, r0
 22c:	e5 9f       	mul	r30, r21
 22e:	30 0d       	add	r19, r0
 230:	f4 9f       	mul	r31, r20
 232:	30 0d       	add	r19, r0
 234:	11 24       	eor	r1, r1
 236:	02 2e       	mov	r0, r18
			E3 = EFram - EBak;				   //Reglerfel: SensorSkillnad 
			Ev =  E3 + (EFram>>2);                 //Totala felet
			Eh =  - E3 - (EFram>>2);

			StyrSignalVanster = mult_k(2*Ev) + mult_kd(Ev - EV_old);  //Y = e*K + KD * e*d/dt 
			StyrSignalHoger = mult_k(2*Eh) + mult_kd(Eh - EH_old);
 238:	23 2f       	mov	r18, r19
 23a:	00 0c       	add	r0, r0
 23c:	22 1f       	adc	r18, r18
 23e:	33 0b       	sbc	r19, r19
 240:	00 0c       	add	r0, r0
 242:	22 1f       	adc	r18, r18
 244:	33 1f       	adc	r19, r19
 246:	08 2e       	mov	r0, r24
 248:	89 2f       	mov	r24, r25
 24a:	00 0c       	add	r0, r0
 24c:	88 1f       	adc	r24, r24
 24e:	99 0b       	sbc	r25, r25
 250:	00 0c       	add	r0, r0
 252:	88 1f       	adc	r24, r24
 254:	99 1f       	adc	r25, r25
 256:	82 0f       	add	r24, r18
 258:	93 1f       	adc	r25, r19
 25a:	06 2e       	mov	r0, r22
				
			EV_old = Ev;  //Gammla styrsignalen
			EH_old = Eh;
			
			//else{
			if (StyrSignalVanster + base_pwm > 170) //Begränsingar för att undvika OverFlow och att roboten rusar iväg
 25c:	67 2f       	mov	r22, r23
 25e:	00 0c       	add	r0, r0
 260:	66 1f       	adc	r22, r22
 262:	77 0b       	sbc	r23, r23
 264:	00 0c       	add	r0, r0
 266:	66 1f       	adc	r22, r22
 268:	77 1f       	adc	r23, r23
 26a:	0a 2e       	mov	r0, r26
 26c:	ab 2f       	mov	r26, r27
 26e:	00 0c       	add	r0, r0
 270:	aa 1f       	adc	r26, r26
 272:	bb 0b       	sbc	r27, r27
 274:	00 0c       	add	r0, r0
 276:	aa 1f       	adc	r26, r26
 278:	bb 1f       	adc	r27, r27
 27a:	6a 0f       	add	r22, r26
 27c:	7b 1f       	adc	r23, r27
 27e:	6b 5a       	subi	r22, 0xAB	; 171
 280:	7f 4f       	sbci	r23, 0xFF	; 255
 282:	6b 3a       	cpi	r22, 0xAB	; 171
 284:	71 05       	cpc	r23, r1
 286:	a0 f5       	brcc	.+104    	; 0x2f0 <Regler_Func+0x1e0>
 288:	64 31       	cpi	r22, 0x14	; 20
			{
				Pwm_left = 170;
			}
			else if (StyrSignalVanster + base_pwm < 20)
 28a:	71 05       	cpc	r23, r1
 28c:	d0 f1       	brcs	.+116    	; 0x302 <Regler_Func+0x1f2>
 28e:	9c 01       	movw	r18, r24
			else
			{
				Pwm_left = (StyrSignalVanster + base_pwm);
			}
			/////////////////////////////////////
			if ( StyrSignalHoger + base_pwm > 170)
 290:	2b 5a       	subi	r18, 0xAB	; 171
 292:	3f 4f       	sbci	r19, 0xFF	; 255
 294:	2b 3a       	cpi	r18, 0xAB	; 171
 296:	31 05       	cpc	r19, r1
 298:	40 f4       	brcc	.+16     	; 0x2aa <Regler_Func+0x19a>
 29a:	24 31       	cpi	r18, 0x14	; 20
			{
				Pwm_right =170;
			}
			else if (StyrSignalHoger + base_pwm < 20)
 29c:	31 05       	cpc	r19, r1
 29e:	68 f0       	brcs	.+26     	; 0x2ba <Regler_Func+0x1aa>
 2a0:	82 2f       	mov	r24, r18
			{
				Pwm_right = 20;
			}
			else
			{
				Pwm_right = (StyrSignalHoger + base_pwm);
 2a2:	20 36       	cpi	r18, 0x60	; 96
			}
			//}
			if ((Pwm_right > base_pwm + 10) && (Pwm_left > base_pwm + 10)){
 2a4:	31 05       	cpc	r19, r1
 2a6:	88 f0       	brcs	.+34     	; 0x2ca <Regler_Func+0x1ba>
 2a8:	01 c0       	rjmp	.+2      	; 0x2ac <Regler_Func+0x19c>
 2aa:	82 2d       	mov	r24, r2
				Pwm_left = (StyrSignalVanster + base_pwm);
			}
			/////////////////////////////////////
			if ( StyrSignalHoger + base_pwm > 170)
			{
				Pwm_right =170;
 2ac:	60 36       	cpi	r22, 0x60	; 96
			else
			{
				Pwm_right = (StyrSignalHoger + base_pwm);
			}
			//}
			if ((Pwm_right > base_pwm + 10) && (Pwm_left > base_pwm + 10)){
 2ae:	71 05       	cpc	r23, r1
 2b0:	60 f0       	brcs	.+24     	; 0x2ca <Regler_Func+0x1ba>
 2b2:	85 e5       	ldi	r24, 0x55	; 85
				Pwm_right = base_pwm;
 2b4:	68 e2       	ldi	r22, 0x28	; 40
				Pwm_left = 40;
 2b6:	70 e0       	ldi	r23, 0x00	; 0
 2b8:	08 c0       	rjmp	.+16     	; 0x2ca <Regler_Func+0x1ba>
 2ba:	84 e1       	ldi	r24, 0x14	; 20
			{
				Pwm_right =170;
			}
			else if (StyrSignalHoger + base_pwm < 20)
			{
				Pwm_right = 20;
 2bc:	06 c0       	rjmp	.+12     	; 0x2ca <Regler_Func+0x1ba>
 2be:	85 e5       	ldi	r24, 0x55	; 85
			{
				Pwm_right = (StyrSignalHoger + base_pwm);
			}
			//}
			if ((Pwm_right > base_pwm + 10) && (Pwm_left > base_pwm + 10)){
				Pwm_right = base_pwm;
 2c0:	68 e2       	ldi	r22, 0x28	; 40
				Pwm_left = 40;
 2c2:	70 e0       	ldi	r23, 0x00	; 0
 2c4:	02 c0       	rjmp	.+4      	; 0x2ca <Regler_Func+0x1ba>
 2c6:	82 2d       	mov	r24, r2
			{
				Pwm_left = 170;
			}
			else if (StyrSignalVanster + base_pwm < 20)
			{
				Pwm_left = 20;
 2c8:	63 2d       	mov	r22, r3
				Pwm_right = base_pwm;
				Pwm_left = 40;
			}
			pwmLeftChar = Pwm_left;
			pwmRightChar = Pwm_right;
			Pwm_Gen(pwmRightChar,pwmLeftChar,1,1);
 2ca:	21 e0       	ldi	r18, 0x01	; 1
 2cc:	41 e0       	ldi	r20, 0x01	; 1
 2ce:	ef de       	rcall	.-546    	; 0xae <Pwm_Gen>

			StyrSignalVanster = mult_k(2*Ev) + mult_kd(Ev - EV_old);  //Y = e*K + KD * e*d/dt 
			StyrSignalHoger = mult_k(2*Eh) + mult_kd(Eh - EH_old);
				
			EV_old = Ev;  //Gammla styrsignalen
			EH_old = Eh;
 2d0:	48 01       	movw	r8, r16
			Eh =  - E3 - (EFram>>2);

			StyrSignalVanster = mult_k(2*Ev) + mult_kd(Ev - EV_old);  //Y = e*K + KD * e*d/dt 
			StyrSignalHoger = mult_k(2*Eh) + mult_kd(Eh - EH_old);
				
			EV_old = Ev;  //Gammla styrsignalen
 2d2:	36 01       	movw	r6, r12
			}
			pwmLeftChar = Pwm_left;
			pwmRightChar = Pwm_right;
			Pwm_Gen(pwmRightChar,pwmLeftChar,1,1);
		}
		Get_Sensor(sen);  //Hämta sensorvärden
 2d4:	ce 01       	movw	r24, r28
 2d6:	01 96       	adiw	r24, 0x01	; 1
 2d8:	0b df       	rcall	.-490    	; 0xf0 <Get_Sensor>
 2da:	f7 01       	movw	r30, r14
	int Ev, Eh, StyrSignalHoger, StyrSignalVanster = 0;
	int EFram, EBak,E3,sensorFram,sensorBak;
	USART1_Flush();
	USART0_Flush();
	Get_Sensor(sen);  //Hämta sensorvärden
	while( !(UCSR0A & (1<<RXC0))) //sålänge den inte mottar en ny instruktion från com
 2dc:	80 81       	ld	r24, Z
 2de:	88 23       	and	r24, r24
 2e0:	0c f0       	brlt	.+2      	; 0x2e4 <Regler_Func+0x1d4>
 2e2:	4e cf       	rjmp	.-356    	; 0x180 <Regler_Func+0x70>
			pwmRightChar = Pwm_right;
			Pwm_Gen(pwmRightChar,pwmLeftChar,1,1);
		}
		Get_Sensor(sen);  //Hämta sensorvärden
	}
	Pwm_Gen(0,0,0,0);
 2e4:	20 e0       	ldi	r18, 0x00	; 0
 2e6:	40 e0       	ldi	r20, 0x00	; 0
 2e8:	60 e0       	ldi	r22, 0x00	; 0
 2ea:	80 e0       	ldi	r24, 0x00	; 0
 2ec:	e0 de       	rcall	.-576    	; 0xae <Pwm_Gen>
 2ee:	12 c0       	rjmp	.+36     	; 0x314 <Regler_Func+0x204>
}
 2f0:	9c 01       	movw	r18, r24
			else
			{
				Pwm_left = (StyrSignalVanster + base_pwm);
			}
			/////////////////////////////////////
			if ( StyrSignalHoger + base_pwm > 170)
 2f2:	2b 5a       	subi	r18, 0xAB	; 171
 2f4:	3f 4f       	sbci	r19, 0xFF	; 255
 2f6:	2b 3a       	cpi	r18, 0xAB	; 171
 2f8:	31 05       	cpc	r19, r1
 2fa:	08 f7       	brcc	.-62     	; 0x2be <Regler_Func+0x1ae>
 2fc:	6a ea       	ldi	r22, 0xAA	; 170
			EH_old = Eh;
			
			//else{
			if (StyrSignalVanster + base_pwm > 170) //Begränsingar för att undvika OverFlow och att roboten rusar iväg
			{
				Pwm_left = 170;
 2fe:	74 2d       	mov	r23, r4
 300:	cc cf       	rjmp	.-104    	; 0x29a <Regler_Func+0x18a>
 302:	9c 01       	movw	r18, r24
			else
			{
				Pwm_left = (StyrSignalVanster + base_pwm);
			}
			/////////////////////////////////////
			if ( StyrSignalHoger + base_pwm > 170)
 304:	2b 5a       	subi	r18, 0xAB	; 171
 306:	3f 4f       	sbci	r19, 0xFF	; 255
 308:	2b 3a       	cpi	r18, 0xAB	; 171
 30a:	31 05       	cpc	r19, r1
 30c:	e0 f6       	brcc	.-72     	; 0x2c6 <Regler_Func+0x1b6>
 30e:	63 2d       	mov	r22, r3
			{
				Pwm_left = 170;
			}
			else if (StyrSignalVanster + base_pwm < 20)
			{
				Pwm_left = 20;
 310:	75 2d       	mov	r23, r5
 312:	c3 cf       	rjmp	.-122    	; 0x29a <Regler_Func+0x18a>
 314:	0f 90       	pop	r0
			Pwm_Gen(pwmRightChar,pwmLeftChar,1,1);
		}
		Get_Sensor(sen);  //Hämta sensorvärden
	}
	Pwm_Gen(0,0,0,0);
}
 316:	0f 90       	pop	r0
 318:	df 91       	pop	r29
 31a:	cf 91       	pop	r28
 31c:	1f 91       	pop	r17
 31e:	0f 91       	pop	r16
 320:	ff 90       	pop	r15
 322:	ef 90       	pop	r14
 324:	df 90       	pop	r13
 326:	cf 90       	pop	r12
 328:	bf 90       	pop	r11
 32a:	af 90       	pop	r10
 32c:	9f 90       	pop	r9
 32e:	8f 90       	pop	r8
 330:	7f 90       	pop	r7
 332:	6f 90       	pop	r6
 334:	5f 90       	pop	r5
 336:	4f 90       	pop	r4
 338:	3f 90       	pop	r3
 33a:	2f 90       	pop	r2
 33c:	08 95       	ret

0000033e <pwm_init>:
 33e:	81 ea       	ldi	r24, 0xA1	; 161
	}
	else 
		Get_Sensor(sens);//Återkallas tills den är i sync
}
void pwm_init(){
	TCCR3A=0b10100001; //Stll in pwm
 340:	80 93 90 00 	sts	0x0090, r24	; 0x800090 <__TEXT_REGION_LENGTH__+0x7e0090>
	TCCR3B=0b00000011;
 344:	83 e0       	ldi	r24, 0x03	; 3
 346:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x7e0091>
	TCNT0 = 0;  //PWM 0-255 (minmax)
 34a:	16 bc       	out	0x26, r1	; 38
	DDRB = 0b11111111; //B utportar
 34c:	8f ef       	ldi	r24, 0xFF	; 255
 34e:	84 b9       	out	0x04, r24	; 4
	DDRD = 0b00001010;
 350:	8a e0       	ldi	r24, 0x0A	; 10
 352:	8a b9       	out	0x0a, r24	; 10
 354:	08 95       	ret

00000356 <Auto_Rotate>:
#define Rotate_speed 90U//PWM för roteringar

void Auto_Rotate(int dir) //Kollar vilket håll vi ska rotera och starta roteringsprogrammet 
{
	
	if (dir==1)  // höger
 356:	01 97       	sbiw	r24, 0x01	; 1
 358:	49 f4       	brne	.+18     	; 0x36c <Auto_Rotate+0x16>
	{
		Pwm_Gen(Rotate_speed,Rotate_speed,1, 0);
 35a:	20 e0       	ldi	r18, 0x00	; 0
 35c:	41 e0       	ldi	r20, 0x01	; 1
 35e:	6a e5       	ldi	r22, 0x5A	; 90
 360:	8a e5       	ldi	r24, 0x5A	; 90
 362:	a5 de       	rcall	.-694    	; 0xae <Pwm_Gen>
		programState = 'D';
 364:	84 e4       	ldi	r24, 0x44	; 68
 366:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
 36a:	08 95       	ret
	}
	else //vänster
	{
		Pwm_Gen(Rotate_speed,Rotate_speed,0, 1 );
 36c:	21 e0       	ldi	r18, 0x01	; 1
 36e:	40 e0       	ldi	r20, 0x00	; 0
 370:	6a e5       	ldi	r22, 0x5A	; 90
 372:	8a e5       	ldi	r24, 0x5A	; 90
 374:	9c de       	rcall	.-712    	; 0xae <Pwm_Gen>
		programState = 'D';
 376:	84 e4       	ldi	r24, 0x44	; 68
 378:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
 37c:	08 95       	ret

0000037e <Auto_Cont>:
	}
	
}
void Auto_Cont(unsigned char inst){        //Kollar vilken typ av automanöver som skall ske
 	unsigned char Auto = inst & 0b00001111;
 37e:	8f 70       	andi	r24, 0x0F	; 15
	if(Auto == 0b00000001)
 380:	81 30       	cpi	r24, 0x01	; 1
 382:	39 f4       	brne	.+14     	; 0x392 <Auto_Cont+0x14>
	{ //fram
		programState = 'F';
 384:	86 e4       	ldi	r24, 0x46	; 70
 386:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
		Regler_Func(0);
 38a:	80 e0       	ldi	r24, 0x00	; 0
 38c:	90 e0       	ldi	r25, 0x00	; 0
 38e:	c0 ce       	rjmp	.-640    	; 0x110 <Regler_Func>
 390:	08 95       	ret
	}
	else if(Auto == 0b00000010){ //bak
 392:	82 30       	cpi	r24, 0x02	; 2
 394:	39 f4       	brne	.+14     	; 0x3a4 <Auto_Cont+0x26>
		programState = 'B';
 396:	82 e4       	ldi	r24, 0x42	; 66
 398:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
		Regler_Func(1);
 39c:	81 e0       	ldi	r24, 0x01	; 1
 39e:	90 e0       	ldi	r25, 0x00	; 0
 3a0:	b7 ce       	rjmp	.-658    	; 0x110 <Regler_Func>
 3a2:	08 95       	ret
	}
	else if(Auto == 0b00000100){ //Rot vnster
 3a4:	84 30       	cpi	r24, 0x04	; 4
 3a6:	39 f4       	brne	.+14     	; 0x3b6 <Auto_Cont+0x38>
		programState = 'L';
 3a8:	8c e4       	ldi	r24, 0x4C	; 76
 3aa:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
		Auto_Rotate(0);
 3ae:	80 e0       	ldi	r24, 0x00	; 0
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	d1 cf       	rjmp	.-94     	; 0x356 <Auto_Rotate>
 3b4:	08 95       	ret
	}
	else if(Auto == 0b00001000){ //Rot hger
 3b6:	88 30       	cpi	r24, 0x08	; 8
 3b8:	31 f4       	brne	.+12     	; 0x3c6 <Auto_Cont+0x48>
		programState = 'R';
 3ba:	82 e5       	ldi	r24, 0x52	; 82
 3bc:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
		Auto_Rotate(1);
 3c0:	81 e0       	ldi	r24, 0x01	; 1
 3c2:	90 e0       	ldi	r25, 0x00	; 0
 3c4:	c8 cf       	rjmp	.-112    	; 0x356 <Auto_Rotate>
 3c6:	08 95       	ret

000003c8 <Man_Cont>:
	}
}
void Man_Cont(unsigned char inst) // Kollar typ av manuell styrinstruktion och sätter PWM till motorerna
{
	char dir = (inst >> 1) & 0b00000001;
 3c8:	81 fb       	bst	r24, 1
 3ca:	44 27       	eor	r20, r20
 3cc:	40 f9       	bld	r20, 0
	char Man = inst & 0b00001111;
	if( Man == 0b00000001 || Man == 0b00000011)
 3ce:	98 2f       	mov	r25, r24
 3d0:	9d 70       	andi	r25, 0x0D	; 13
 3d2:	91 30       	cpi	r25, 0x01	; 1
 3d4:	29 f4       	brne	.+10     	; 0x3e0 <Man_Cont+0x18>
		{
			Pwm_Gen(Man_speed,Man_speed, dir, dir);
 3d6:	24 2f       	mov	r18, r20
 3d8:	6c ed       	ldi	r22, 0xDC	; 220
 3da:	8c ed       	ldi	r24, 0xDC	; 220
 3dc:	68 ce       	rjmp	.-816    	; 0xae <Pwm_Gen>
 3de:	08 95       	ret
	}
}
void Man_Cont(unsigned char inst) // Kollar typ av manuell styrinstruktion och sätter PWM till motorerna
{
	char dir = (inst >> 1) & 0b00000001;
	char Man = inst & 0b00001111;
 3e0:	8f 70       	andi	r24, 0x0F	; 15
	if( Man == 0b00000001 || Man == 0b00000011)
		{
			Pwm_Gen(Man_speed,Man_speed, dir, dir);
		}
		else if(Man == 0b00000100)		//Rot vänster
 3e2:	84 30       	cpi	r24, 0x04	; 4
 3e4:	49 f4       	brne	.+18     	; 0x3f8 <Man_Cont+0x30>
		{
			programState ='V';
 3e6:	86 e5       	ldi	r24, 0x56	; 86
 3e8:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
			Pwm_Gen(Man_speed,Man_speed,0,1); // 01
 3ec:	21 e0       	ldi	r18, 0x01	; 1
 3ee:	40 e0       	ldi	r20, 0x00	; 0
 3f0:	6c ed       	ldi	r22, 0xDC	; 220
 3f2:	8c ed       	ldi	r24, 0xDC	; 220
 3f4:	5c ce       	rjmp	.-840    	; 0xae <Pwm_Gen>
 3f6:	08 95       	ret
		}
		else if( Man == 0b00001000)			// Rot höger
 3f8:	88 30       	cpi	r24, 0x08	; 8
 3fa:	49 f4       	brne	.+18     	; 0x40e <__LOCK_REGION_LENGTH__+0xe>
		{
			programState ='H';
 3fc:	88 e4       	ldi	r24, 0x48	; 72
 3fe:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <programState>
			Pwm_Gen(Man_speed,Man_speed,1,0);
 402:	20 e0       	ldi	r18, 0x00	; 0
 404:	41 e0       	ldi	r20, 0x01	; 1
 406:	6c ed       	ldi	r22, 0xDC	; 220
 408:	8c ed       	ldi	r24, 0xDC	; 220
 40a:	51 ce       	rjmp	.-862    	; 0xae <Pwm_Gen>
 40c:	08 95       	ret
		}
		else if(Man == 0b00000111)			// Svng vänster framt
 40e:	87 30       	cpi	r24, 0x07	; 7
 410:	29 f4       	brne	.+10     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
		{
			Pwm_Gen(Man_speed,Turn_speed,dir,dir);
 412:	24 2f       	mov	r18, r20
 414:	60 e5       	ldi	r22, 0x50	; 80
 416:	8c ed       	ldi	r24, 0xDC	; 220
 418:	4a ce       	rjmp	.-876    	; 0xae <Pwm_Gen>
 41a:	08 95       	ret
		}
		else if (Man == 0b00001011)               // Svng höger framt
 41c:	8b 30       	cpi	r24, 0x0B	; 11
		{
			Pwm_Gen(Turn_speed,Man_speed,dir,dir);
 41e:	29 f4       	brne	.+10     	; 0x42a <__LOCK_REGION_LENGTH__+0x2a>
 420:	24 2f       	mov	r18, r20
 422:	6c ed       	ldi	r22, 0xDC	; 220
 424:	80 e5       	ldi	r24, 0x50	; 80
 426:	43 ce       	rjmp	.-890    	; 0xae <Pwm_Gen>
 428:	08 95       	ret
		}
		else if(Man == 0b00000101)
 42a:	85 30       	cpi	r24, 0x05	; 5
		{
			Pwm_Gen(Turn_speed,Man_speed,dir,dir); // Svng hger bakt
 42c:	29 f4       	brne	.+10     	; 0x438 <__LOCK_REGION_LENGTH__+0x38>
 42e:	24 2f       	mov	r18, r20
 430:	6c ed       	ldi	r22, 0xDC	; 220
 432:	80 e5       	ldi	r24, 0x50	; 80
 434:	3c ce       	rjmp	.-904    	; 0xae <Pwm_Gen>
		}
		else if (Man == 0b00001001)
 436:	08 95       	ret
 438:	89 30       	cpi	r24, 0x09	; 9
		{
			Pwm_Gen(Man_speed,Turn_speed,dir,dir); // Svng vnster bakt
 43a:	29 f4       	brne	.+10     	; 0x446 <__LOCK_REGION_LENGTH__+0x46>
 43c:	24 2f       	mov	r18, r20
 43e:	60 e5       	ldi	r22, 0x50	; 80
 440:	8c ed       	ldi	r24, 0xDC	; 220
 442:	35 ce       	rjmp	.-918    	; 0xae <Pwm_Gen>
		}
		else
		{
			Pwm_Gen(0,0,dir,dir);
 444:	08 95       	ret
 446:	24 2f       	mov	r18, r20
 448:	60 e0       	ldi	r22, 0x00	; 0
 44a:	80 e0       	ldi	r24, 0x00	; 0
 44c:	30 ce       	rjmp	.-928    	; 0xae <Pwm_Gen>
 44e:	08 95       	ret

00000450 <main>:
		}
	}
int main(void)
{
		UART_Init_sens();
 450:	6d d0       	rcall	.+218    	; 0x52c <UART_Init_sens>
		pwm_init();
 452:	75 df       	rcall	.-278    	; 0x33e <pwm_init>
		UART_Init_com();
 454:	5f d0       	rcall	.+190    	; 0x514 <UART_Init_com>
 456:	80 e2       	ldi	r24, 0x20	; 32
		
		K = 32;
 458:	90 e0       	ldi	r25, 0x00	; 0
 45a:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <K+0x1>
 45e:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <K>
 462:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <KR+0x1>
		KR = 0;
 466:	10 92 05 01 	sts	0x0105, r1	; 0x800105 <KR>
 46a:	8e e1       	ldi	r24, 0x1E	; 30
		KD = 30;
 46c:	90 e0       	ldi	r25, 0x00	; 0
 46e:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <_edata+0x1>
 472:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 476:	d1 e4       	ldi	r29, 0x41	; 65
					programState = 'M';
					Man_Cont(inst);
				}
				else if(Mode == 0 )
				{
					programState = 'A';
 478:	0f 2e       	mov	r0, r31
				{
					KR = inst & 0b00111111;
				}
				else if(Mode == 1 )
				{
					programState = 'M';
 47a:	fd e4       	ldi	r31, 0x4D	; 77
 47c:	ff 2e       	mov	r15, r31
 47e:	f0 2d       	mov	r31, r0
		unsigned char inst = 0b00000000;
		int Mode;
		{
			while(1)
			{
				UART_Transmit_sens('W'); //skickar 'väntar på instr från com'
 480:	87 e5       	ldi	r24, 0x57	; 87
 482:	70 d0       	rcall	.+224    	; 0x564 <UART_Transmit_sens>
 484:	67 d0       	rcall	.+206    	; 0x554 <UART_Recieve_com>
				inst = UART_Recieve_com();  //Hämtar instruktion från kommunikationsmodulen
 486:	c8 2f       	mov	r28, r24
 488:	80 91 02 01 	lds	r24, 0x0102	; 0x800102 <programState>
				UART_Transmit_sens(programState); //återställer 
 48c:	6b d0       	rcall	.+214    	; 0x564 <UART_Transmit_sens>
 48e:	c1 11       	cpse	r28, r1
 490:	06 c0       	rjmp	.+12     	; 0x49e <main+0x4e>
				
				Mode = (inst>>4) & 0b00000001;
				
				if ( inst == 0b00000000)
 492:	20 e0       	ldi	r18, 0x00	; 0
				{
					Pwm_Gen(0x00,0x00,0,0);
 494:	40 e0       	ldi	r20, 0x00	; 0
 496:	60 e0       	ldi	r22, 0x00	; 0
 498:	80 e0       	ldi	r24, 0x00	; 0
 49a:	09 de       	rcall	.-1006   	; 0xae <Pwm_Gen>
 49c:	36 c0       	rjmp	.+108    	; 0x50a <main+0xba>
 49e:	8c 2f       	mov	r24, r28
 4a0:	82 95       	swap	r24
				}
				if ( ((inst>>6) & 0b00000011) == 2)
 4a2:	86 95       	lsr	r24
 4a4:	86 95       	lsr	r24
 4a6:	83 70       	andi	r24, 0x03	; 3
 4a8:	82 30       	cpi	r24, 0x02	; 2
 4aa:	69 f4       	brne	.+26     	; 0x4c6 <main+0x76>
 4ac:	cf 77       	andi	r28, 0x7F	; 127
 4ae:	8c 2f       	mov	r24, r28
				{
					K = inst & 0b01111111;
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	90 93 04 01 	sts	0x0104, r25	; 0x800104 <K+0x1>
 4b6:	80 93 03 01 	sts	0x0103, r24	; 0x800103 <K>
 4ba:	20 e0       	ldi	r18, 0x00	; 0
					
					Pwm_Gen(0x00,0x00,0,0);
 4bc:	40 e0       	ldi	r20, 0x00	; 0
 4be:	60 e0       	ldi	r22, 0x00	; 0
 4c0:	80 e0       	ldi	r24, 0x00	; 0
 4c2:	f5 dd       	rcall	.-1046   	; 0xae <Pwm_Gen>
 4c4:	dd cf       	rjmp	.-70     	; 0x480 <main+0x30>
 4c6:	81 30       	cpi	r24, 0x01	; 1
 4c8:	41 f4       	brne	.+16     	; 0x4da <main+0x8a>
				}
				else if (( ((inst>>6) & 0b00000011) == 1))
 4ca:	cf 73       	andi	r28, 0x3F	; 63
 4cc:	8c 2f       	mov	r24, r28
				{
					KD = inst & 0b00111111;
 4ce:	90 e0       	ldi	r25, 0x00	; 0
 4d0:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <_edata+0x1>
 4d4:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <_edata>
 4d8:	d3 cf       	rjmp	.-90     	; 0x480 <main+0x30>
 4da:	83 30       	cpi	r24, 0x03	; 3
 4dc:	41 f4       	brne	.+16     	; 0x4ee <main+0x9e>
				}
				else if (( ((inst>>6) & 0b00000011) == 3))
 4de:	cf 73       	andi	r28, 0x3F	; 63
 4e0:	8c 2f       	mov	r24, r28
				{
					KR = inst & 0b00111111;
 4e2:	90 e0       	ldi	r25, 0x00	; 0
 4e4:	90 93 06 01 	sts	0x0106, r25	; 0x800106 <KR+0x1>
 4e8:	80 93 05 01 	sts	0x0105, r24	; 0x800105 <KR>
 4ec:	c9 cf       	rjmp	.-110    	; 0x480 <main+0x30>
 4ee:	c4 fb       	bst	r28, 4
 4f0:	00 27       	eor	r16, r16
				}
				else if(Mode == 1 )
 4f2:	00 f9       	bld	r16, 0
 4f4:	10 e0       	ldi	r17, 0x00	; 0
 4f6:	c4 ff       	sbrs	r28, 4
 4f8:	05 c0       	rjmp	.+10     	; 0x504 <main+0xb4>
 4fa:	f0 92 02 01 	sts	0x0102, r15	; 0x800102 <programState>
				{
					programState = 'M';
 4fe:	8c 2f       	mov	r24, r28
					Man_Cont(inst);
 500:	63 df       	rcall	.-314    	; 0x3c8 <Man_Cont>
 502:	be cf       	rjmp	.-132    	; 0x480 <main+0x30>
 504:	01 2b       	or	r16, r17
				}
				else if(Mode == 0 )
 506:	09 f0       	breq	.+2      	; 0x50a <main+0xba>
 508:	bb cf       	rjmp	.-138    	; 0x480 <main+0x30>
 50a:	d0 93 02 01 	sts	0x0102, r29	; 0x800102 <programState>
				{
					programState = 'A';
 50e:	8c 2f       	mov	r24, r28
					Auto_Cont(inst);
 510:	36 df       	rcall	.-404    	; 0x37e <Auto_Cont>
 512:	b6 cf       	rjmp	.-148    	; 0x480 <main+0x30>

00000514 <UART_Init_com>:
#define BAUD_SENS 31
#define BAUD_COM 23

void UART_Init_com()
{
	UCSR0B = (1<<RXEN0)|(0<<TXEN0);//|(1<<RXCIE0);
 514:	80 e1       	ldi	r24, 0x10	; 16
 516:	80 93 c1 00 	sts	0x00C1, r24	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
	//Baudrate
	UBRR0H = (BAUD_COM>>8);
 51a:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7e00c5>
	UBRR0L = BAUD_COM;
 51e:	87 e1       	ldi	r24, 0x17	; 23
 520:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7e00c4>
	//enable recieve
	//stopbitar, 1
	UCSR0C =  (1<<USBS0)|(3<<UCSZ00);
 524:	8e e0       	ldi	r24, 0x0E	; 14
 526:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7e00c2>
 52a:	08 95       	ret

0000052c <UART_Init_sens>:
}
void UART_Init_sens()
{
	UCSR1B = (1<<RXEN1)|(1<<TXEN1);//|(1<<RXCIE1);
 52c:	88 e1       	ldi	r24, 0x18	; 24
 52e:	80 93 c9 00 	sts	0x00C9, r24	; 0x8000c9 <__TEXT_REGION_LENGTH__+0x7e00c9>
	//Baudrate
	UBRR1H = (unsigned char)(BAUD_SENS>>8);
 532:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__TEXT_REGION_LENGTH__+0x7e00cd>
	UBRR1L = (unsigned char)BAUD_SENS;
 536:	8f e1       	ldi	r24, 0x1F	; 31
 538:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__TEXT_REGION_LENGTH__+0x7e00cc>
	//enable transmit/recieve
	//stopbitar, 1
	UCSR1C = (1<<USBS1)|(3<<UCSZ10);
 53c:	8e e0       	ldi	r24, 0x0E	; 14
 53e:	80 93 ca 00 	sts	0x00CA, r24	; 0x8000ca <__TEXT_REGION_LENGTH__+0x7e00ca>
 542:	08 95       	ret

00000544 <UART_Recieve_sens>:
}
unsigned char UART_Recieve_sens()
{
	while( !(UCSR1A & (1<<RXC1)) );
 544:	e8 ec       	ldi	r30, 0xC8	; 200
 546:	f0 e0       	ldi	r31, 0x00	; 0
 548:	80 81       	ld	r24, Z
 54a:	88 23       	and	r24, r24
 54c:	ec f7       	brge	.-6      	; 0x548 <UART_Recieve_sens+0x4>
	return UDR1;
 54e:	80 91 ce 00 	lds	r24, 0x00CE	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
}
 552:	08 95       	ret

00000554 <UART_Recieve_com>:
unsigned char UART_Recieve_com()
{
	while( !(UCSR0A & (1<<RXC0)) );
 554:	e0 ec       	ldi	r30, 0xC0	; 192
 556:	f0 e0       	ldi	r31, 0x00	; 0
 558:	80 81       	ld	r24, Z
 55a:	88 23       	and	r24, r24
 55c:	ec f7       	brge	.-6      	; 0x558 <UART_Recieve_com+0x4>
	return UDR0;
 55e:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__TEXT_REGION_LENGTH__+0x7e00c6>
}
 562:	08 95       	ret

00000564 <UART_Transmit_sens>:
void UART_Transmit_sens(unsigned char data)
{
	while( !(UCSR1A & (1<<UDRE1)) );
 564:	e8 ec       	ldi	r30, 0xC8	; 200
 566:	f0 e0       	ldi	r31, 0x00	; 0
 568:	90 81       	ld	r25, Z
 56a:	95 ff       	sbrs	r25, 5
 56c:	fd cf       	rjmp	.-6      	; 0x568 <UART_Transmit_sens+0x4>
	UDR1 = data;
 56e:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__TEXT_REGION_LENGTH__+0x7e00ce>
 572:	08 95       	ret

00000574 <USART1_Flush>:
}
void USART1_Flush( void )
{
	unsigned char dummy;
	while ( UCSR1A & (1<<RXC1) ) dummy = UDR1;
 574:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__TEXT_REGION_LENGTH__+0x7e00c8>
 578:	88 23       	and	r24, r24
 57a:	44 f4       	brge	.+16     	; 0x58c <USART1_Flush+0x18>
 57c:	ae ec       	ldi	r26, 0xCE	; 206
 57e:	b0 e0       	ldi	r27, 0x00	; 0
 580:	e8 ec       	ldi	r30, 0xC8	; 200
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	8c 91       	ld	r24, X
 586:	80 81       	ld	r24, Z
 588:	88 23       	and	r24, r24
 58a:	e4 f3       	brlt	.-8      	; 0x584 <USART1_Flush+0x10>
 58c:	08 95       	ret

0000058e <USART0_Flush>:
	
}
void USART0_Flush( void )
{
	unsigned char dummy;
	while ( UCSR0A & (1<<RXC0) ) dummy = UDR0;
 58e:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__TEXT_REGION_LENGTH__+0x7e00c0>
 592:	88 23       	and	r24, r24
 594:	44 f4       	brge	.+16     	; 0x5a6 <USART0_Flush+0x18>
 596:	a6 ec       	ldi	r26, 0xC6	; 198
 598:	b0 e0       	ldi	r27, 0x00	; 0
 59a:	e0 ec       	ldi	r30, 0xC0	; 192
 59c:	f0 e0       	ldi	r31, 0x00	; 0
 59e:	8c 91       	ld	r24, X
 5a0:	80 81       	ld	r24, Z
 5a2:	88 23       	and	r24, r24
 5a4:	e4 f3       	brlt	.-8      	; 0x59e <USART0_Flush+0x10>
 5a6:	08 95       	ret

000005a8 <_exit>:
 5a8:	f8 94       	cli

000005aa <__stop_program>:
 5aa:	ff cf       	rjmp	.-2      	; 0x5aa <__stop_program>
